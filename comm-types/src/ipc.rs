//! Types used in IPC between runner and monitor
use ciborium::de::from_reader;
use hyper::body::Buf;
use hyper::{header, Body, Response};
use serde::{Deserialize, Serialize};
use thiserror::Error;

use super::cbor::CBOR_MIME;
use super::hardware::{ProbeInfo, TargetState};
use super::results::TestResults;

/// All possible message types that can be sent via Hive IPC
#[derive(Debug, Serialize, Deserialize)]
pub enum IpcMessage {
    /// Information on the connected probes required by the runner
    ProbeInitData([Option<ProbeInfo>; 4]),
    /// Information on the connected targets required by the runner
    TargetInitData([Option<[TargetState; 4]>; 8]),
    /// Log generated by the runner on a test run
    RunnerLog,
    /// Test results generated by the runner
    TestResults(TestResults),
    /// Generic Ipc error, in case of wrong requests, etc
    IpcError(String),
    /// Desync error returned by runner, in case the received probe and target data does not seem to match the hardware detected by the runner
    DesyncError,
    /// Empty value
    Empty,
}

#[derive(Debug, Error)]
pub enum ParseError {
    #[error(
        "Response had an invalid header configuration, check that content-type is application/cbor"
    )]
    InvalidHeader,
    #[error(
        "Failed to deserialize CBOR body as IpcMessage, check that the server sends the correct types"
    )]
    InvalidCbor,
    #[error("Response contained invalid body format")]
    InvalidBody,
}

impl IpcMessage {
    /// Tries to parse an [`IpcMessage`] from the provided HTTP response
    pub async fn from_response(res: Response<Body>) -> Result<Self, ParseError> {
        if res.headers().get(header::CONTENT_TYPE).is_some() {
            if res.headers().get(header::CONTENT_TYPE).unwrap() != CBOR_MIME {
                return Err(ParseError::InvalidHeader);
            }
        } else {
            return Err(ParseError::InvalidHeader);
        }

        let body = hyper::body::aggregate(res)
            .await
            .map_err(|_| ParseError::InvalidBody)?;
        let msg = from_reader(body.reader()).map_err(|_| ParseError::InvalidCbor)?;

        Ok(msg)
    }
}
