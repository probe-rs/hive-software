//! Hive defines
//!
//! Hive defines are a way to insert dynamic variables into a testprogram which can be regenerated by the monitor before every test run.
//! The defines are also made available to each Hive testfunction, therefore they are a good way to implement dynamic values directly into the
//! testprogram build process and test against those variables during a test run.
//!
//! Anything that can implement [`HiveDefine`] can be used as a Hive define.
use std::{any::type_name, collections::HashMap};

use downcast_rs::{Downcast, impl_downcast};
use dyn_clone::{DynClone, clone_trait_object};
use serde::{Deserialize, Serialize};

mod uid;

pub use self::uid::HiveUid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DefineRegistry {
    registered_defines: HashMap<String, Box<dyn HiveDefine>>,
}

impl Default for DefineRegistry {
    fn default() -> Self {
        Self::new()
    }
}

impl DefineRegistry {
    pub fn new() -> Self {
        Self {
            registered_defines: HashMap::new(),
        }
    }

    /// Registers a new define
    ///
    /// # Panics
    /// If a define with the same key is already registered in the registry. This can be caused by registring the same Define twice or by having two Defines with the same key
    pub fn register<D: 'static + HiveDefine>(&mut self, define: Box<D>) {
        if self
            .registered_defines
            .insert(type_name::<D>().to_owned(), define)
            .is_some()
        {
            panic!(
                "Failed to register define as it is already present in the registry. You might have registered it twice or you created two different defines with the same keys"
            );
        }
    }

    /// Returns all active defines which are to be included in the final `hive_defines.S` file.
    ///
    /// If you create a new impl of [`HiveDefine`], you need to add it to the vector which is returned by this function in order for it to get generated in the final file.
    pub fn get_active_defines(&mut self) -> &mut HashMap<String, Box<dyn HiveDefine>> {
        &mut self.registered_defines
    }

    /// Get a Hive Define
    ///
    /// # Panics
    /// If the requested define is not found in the registry
    pub fn get_define<D: HiveDefine>(&self) -> &D {
        self.registered_defines
            .get(type_name::<D>())
            .expect("Failed to find the requested Hive Define in the registry")
            .downcast_ref()
            .expect("Failed to downcast HiveDefine trait to the requested type")
    }
}

/// This trait implementation makes a type capable to act as a Hive define
#[typetag::serde]
pub trait HiveDefine: std::fmt::Debug + DynClone + Send + Sync + Downcast {
    /// The generate function is called before a new hive_defines file is created. It can be used to generate a unique ID for every test run for example.
    fn generate(&mut self);

    /// The returned String represents a file line in the final `hive_defines.S` file which is being used by every Hive testprogram
    fn to_file_line(&self) -> String;
}
impl_downcast!(HiveDefine);
clone_trait_object!(HiveDefine);

#[cfg(test)]
mod tests {
    use serde::{Deserialize, Serialize};

    use super::{DefineRegistry, HiveDefine, HiveUid};

    /// Dummy Hive define used in tests
    #[derive(Debug, Clone, Serialize, Deserialize)]
    struct SomeDefine;

    impl SomeDefine {
        fn new() -> Self {
            Self
        }
    }

    #[typetag::serde]
    impl HiveDefine for SomeDefine {
        fn generate(&mut self) {}

        fn to_file_line(&self) -> String {
            String::from("test")
        }
    }

    #[test]
    #[should_panic]
    fn register_multiple_identical() {
        let mut registry = DefineRegistry::new();

        registry.register(Box::new(HiveUid::new()));

        registry.register(Box::new(HiveUid::new()));
    }

    #[test]
    fn get_define() {
        let mut registry = DefineRegistry::new();

        registry.register(Box::new(HiveUid::new()));

        let _registered_define = registry.get_define::<HiveUid>();
    }

    #[test]
    #[should_panic]
    fn get_nonexistent_define() {
        let mut registry = DefineRegistry::new();

        registry.register(Box::new(HiveUid::new()));

        let _nonexistent_define = registry.get_define::<SomeDefine>();
    }

    #[test]
    fn register_multiple() {
        let mut registry = DefineRegistry::new();

        registry.register(Box::new(HiveUid::new()));
        registry.register(Box::new(SomeDefine::new()));
    }
}
